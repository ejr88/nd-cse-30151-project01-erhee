# -*- coding: utf-8 -*-
"""2SAT_code_erhee.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zGjl0vOTe9diIbeaY9cIt47UNuCF4FV-
"""

# 2-SAT DPLL
import csv
import numpy as np
import matplotlib.pyplot as plt
from numpy.polynomial import Polynomial
import time

def unit_propagate(clause_list, assign): # clause_list = the list of lists of clauses, variables = assignments associated with a clause list

  # find the unit clauses
  unit_clauses = [] # list of unit clauses
  for clause in clause_list:
    if len(clause) == 1:
      unit_clauses.append(clause[0]) # get the only element in clause

  while unit_clauses:
    unit_lit = unit_clauses.pop() # get a unit clause to analyze
    if unit_lit > 0:
      assign[abs(unit_lit)-1] = True # assign the literal to true if it is positive
    else:
      assign[abs(unit_lit)-1] = False # assign the literal to false if it is negative

    new_clause_list = []
    for clause in clause_list: # remove the unit clause from the clause list
      if unit_lit in clause:
        continue
      update_clause = [lit for lit in clause if lit != -unit_lit]
      new_clause_list.append(update_clause)

    clause_list = new_clause_list # update the clause_list
    unit_clauses = [clause[0] for clause in clause_list if len(clause) == 1]

  return clause_list, assign

def pure_literal_elim(clause_list, assign):
  literal_count = {} # create a list to keep track of the literals in the clauses

  for clause in clause_list: # check each clause
    for literal in clause: # check each literal
      if literal not in literal_count: # check if the literals have been seen already
        literal_count[literal] = 0 # initialize it to the list if it was not seen before
      literal_count[literal] += 1

  pure_lits = [] # list to store pure literals
  for literal in literal_count.keys():
    if -literal not in literal_count:
      pure_lits.append(literal)

  while pure_lits:
    pure_lit = pure_lits.pop()
    if pure_lit > 0: # find a unit > 0, assign true - remove the whole clause if it is true
      assign[abs(pure_lit)-1] = True
    else: # find a unit < 0, assign false - also remove whole clause
      assign[abs(pure_lit)-1] = False

    clause_list = [clause for clause in clause_list if pure_lit not in clause] # remove the clause

  return clause_list, assign

def dpll_func(clause_list, assign):
  # check unit propagation and pure literal elimination
  clause_list, assign = unit_propagate(clause_list, assign)
  clause_list, assign = pure_literal_elim(clause_list, assign)

  if not clause_list: # if it empty all clauses are satisfied return true
    return True

  for clause in clause_list: # if there is an empty clause return false
    if len(clause) == 0:
      return False

  # DPLL- choose literal
  literal = None
  for clause in clause_list:
    for lit in clause: # choose first literal
      literal = lit
      break
    if literal: # break if the literal is an actual value
      break

  if literal is None: # if there is no literal, return true because it is satisfied
    return True

  return dpll_func((clause_list + [[literal]]), assign) or dpll_func((clause_list + [[-literal]]), assign)

def csv_output(num_lits, times, satisfiability):
  with open('Output_test_erhee.csv', 'w', newline='') as file:
    writer = csv.writer(file)
    # output the number of literals, the time, and the truth value
    writer.writerow(['Number of Literals', 'Time', 'Truth Value']) # create a header
    for i in range(len(num_lits)):
      writer.writerow([num_lits[i], times[i], satisfiability[i]])
  return

# MAIN FUNCTION
# initialize all of the lists to be used
clauses = []
clause_list = []
num_literals = []
times = []
sats = []
truth = None
color_points = []
problem_clauses = []
problem_nums = []
num = 0
num_vars = []
num_clauses = []
lenc = []

file_name = "check_2SAT_code.cnf.csv"
with open(file_name, mode ='r')as file:
  csvFile = csv.reader(file)

  for lines in csvFile:
    if lines[0] == '\ufeffc': # first c has this differenct value- must get
      problem_nums.append(lines[1])
      continue

    if lines[0] == 'c':
      problem_nums.append(lines[1])
      problem_clauses = clause_list # save all the clauses per problem as one element per problem
      #clause_list = [] # reset the clause list for a new problem
      start = time.time()
      truth = dpll_func(clause_list, assign)
      end = time.time()
      times.append(round((end-start)*(10**6), 2))# total time for each problem- change to microsec and round to 2 decimal places
      sats.append(truth)
      clause_list = [] # reset the clause list for a new problem
      if truth == True:
        print(f"Problem {problem_nums[num]} is Satisfiable")
        color_points.append('green')
      else:
        print(f"Problem {problem_nums[num]} is Unsatisfiable")
        color_points.append('red')
      clause_list = [] # rest clause_list to get all the clauses for the next problem
      num += 1 # increment the problem number
      continue

    if lines[0] == 'p':
      num_vars = int(lines[2])
      num_clauses = int(lines[3])
      assign = [None] * num_vars # so you do not index out of range
      num_literals.append(num_clauses*2)
      continue

    if lines[0] != 'p' and lines[0] != 'c':
      for val in lines:
        if val == '':
          continue
        if val == 0:
          continue
        if val == 'p'or val == 'c':
          clauses.append(int(val))
      clause_list.append(clauses)
      clauses = [] # reset

# check last problem because there is no c after the last values
start = time.time()
truth = dpll_func(clause_list, assign)
end = time.time()
times.append(round((end-start)*(10**6), 2))# total time for each problem- change to microsec and round to 2 decimal places
sats.append(truth)
clause_list = [] # reset the clause list for a new problem
if truth == True:
  print(f"Problem {problem_nums[num]} is Satisfiable")
  color_points.append('green')
else:
  print(f"Problem {problem_nums[num]} is Unsatisfiable")
  color_points.append('red')
  clause_list = [] # rest clause_list to get all the clauses for the next problem

# plot graph
plt.xlabel("Number of Literals")
plt.ylabel("Time")
plt.title("Literals over time analysis")
plt.grid(True)

plt.scatter(num_literals, times, color=color_points)

degree = 2
coefficients = np.polynomial.Polynomial.fit(num_literals, times, degree) # use polynomial fit to better fit the data

x_values = np.linspace(min(num_literals), max(num_literals), 100) # create trend line
y_values = coefficients(x_values) # get corresponding y values to x trend line

plt.plot(x_values, y_values, color='blue', label='Trend Line')
plt.legend()

plt.show()

# generate output of the values to a file
csv_output(num_literals, times, sats)